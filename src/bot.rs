// bot.rs
//! This module creates a bot!
use crate::decoder;

use dotenv::dotenv;
use reqwest::{header, Client, StatusCode};
use serde::{Deserialize, Serialize};
// use serde_json;
// use serde_json::json;
use std::env;

// ==> STRUCTS for elements of the request body (üåê: https://ai.google.dev/gemini-api/docs/get-started/rest)
// 1. Request Payload
#[rustfmt::skip]
#[derive(Serialize, Deserialize)]
struct RequestPayload { contents: Vec<Content> }

/// ## Candidate
///
/// A response candidate generated by the model.
///
/// This struct represents a single possible response generated by the Gemini Pro model. It includes the generated content, information about why the generation stopped, safety ratings, and other metadata.
///
/// For more details, see the official documentation:
/// https://ai.google.dev/api/rest/v1beta/Candidate
///
/// ### Fields
///
/// - `content: Content` - The generated content returned from the model.
/// - `finishReason: FinishReason` - _(Optional)_ The reason why the model stopped generating tokens. Possible values at https://ai.google.dev/api/rest/v1beta/Candidate#finishreason:
/// - `safetyRatings: Vec<SafetyRating>` - A list of ratings for the safety of the response candidate. There is at most one rating per category.
/// - `citationMetadata: CitationMetadata` - _(Optional)_ Citation information for model-generated content. This field may be populated with recitation information for any text included in the content that is derived from copyrighted material in the foundational LLM's training data.
/// - `tokenCount: u32:` - _(Optional)_ The number of tokens in this candidate's output.
/// - `groundingAttributions: (Vec<GroundingAttribution>)` - _(Optional)_ Attribution information for sources that contributed to a grounded answer. This field is populated for `GenerateAnswer` calls.
/// - `index: (u32)` - The index of the candidate in the list of candidates. 

#[rustfmt::skip]
#[allow(non_snake_case)]
#[allow(dead_code)]
#[derive(Deserialize)]
struct Candidate { content: Content, safetyRatings: Vec<SafetyRating>, 
} // ignoring snake_case,needs to match API's field name

/// ## Content
///
/// The base structured data type for multi-part content of a message.
///
/// This struct represents a single unit of content within a message, such as a user's prompt or the model's response. It consists of an ordered list of parts, each potentially having a different MIME type (e.g., `text/plain`, `image/png`), and a `role` field designating the content's producer.
///
/// For more details, refer to the official documentation:
/// https://ai.google.dev/api/rest/v1beta/Content
///
/// ### Fields
///
/// - `parts` (`Vec<Part>`): An ordered list of `Part` objects. Each `Part` constitutes a segment of the message and can contain text, images, or other media types.
/// - `role` (`String`, optional): The producer of the content, either `"user"` or `"model"`. This is crucial for distinguishing between user input and AI-generated responses, especially in multi-turn conversations. While optional, it's recommended to set this field for clarity. 

#[rustfmt::skip]
#[derive(Serialize, Deserialize, Debug)]
struct Content { parts: Vec<Part> }

/// ## Part
///
/// A data type containing media that is part of a multi-part `Content` message.
///
/// This struct represents a single segment within a `Content` object. It holds data that has an associated data type, indicated by the `data` field. A `Part` can contain only one of the accepted types in the `data` union.
///
/// For more details, refer to the official documentation:
/// https://ai.google.dev/api/rest/v1beta/Part
///
/// ### Fields
///
/// - `data` (Union): The data contained within this `Part`. This can be one of the following types:
///    - `text` (`String`): Inline text content.
///    - `inlineData` (`Blob`): Inline media bytes (e.g., image data).
///    - `functionCall` (`FunctionCall`): A predicted function call returned from the model.
///    - `functionResponse` (`FunctionResponse`): The result output of a function call.
///    - `fileData` (`FileData`): URI-based data (e.g., a link to an external file).

#[rustfmt::skip]
#[derive(Serialize, Deserialize, Debug)]
struct Part { text: String }

/// ## Prompt
/// Contains `text` of type `String`

#[rustfmt::skip]
#[derive(Serialize, Deserialize, Debug)]
struct Prompt { text: String }

// 5. Response Payload
#[rustfmt::skip]
#[allow(dead_code)]
#[derive(Deserialize)]
struct ResponsePayload { candidates: Vec<Candidate> }

/// ## SafetyRating
///
/// Safety rating for a piece of content.
///
/// This struct provides information about the potential harm associated with a piece of content. It includes the category of harm, the probability of that harm occurring, and whether the content was blocked based on this rating.
///
/// ### Fields
/// 
/// - `category` (`HarmCategory`) - The category of harm that this rating assesses. This is a required field and indicates the type of potential harm, such as sexually explicit content or hate speech.
/// - `probability` (`HarmProbability`) - The probability of the identified harm occurring. This is a required field and indicates how likely it is for the content to be harmful within the given category.
/// - `blocked` (`bool`) - Whether or not the content was blocked due to this safety rating. This is an optional field that might not be present in every response.

#[rustfmt::skip]
#[allow(dead_code)]
#[derive(Deserialize)]
struct SafetyRating { category: String, probability: String }

/// ## `SafetySetting`
///
/// Safety setting, affecting the safety-blocking behavior of the model.
///
/// This struct is used to configure the model's sensitivity to potentially harmful content. By adjusting the `threshold` for different harm categories, you can control when the model should block the generation of responses.
///
/// ### Fields
///
/// - `category` (`HarmCategory`): The category of potentially harmful content this setting applies to.
/// - `threshold` (`HarmBlockThreshold`): The probability threshold at which content in the specified category will be blocked. 

#[rustfmt::skip]
#[derive(Serialize, Deserialize, Debug)]
struct SafetySetting { category: String, threshold: u32 }

/// ## `generate_completion`
///
/// Generates a text completion using the Gemini Pro API.
///
/// This asynchronous function sends a request to the Gemini Pro API to generate a text completion based on the provided prompt. It handles the API request, error handling, and parsing of the response.
///
/// ### Arguments
///
/// - `prompt` (`&str`): The text prompt used to guide the text generation.
///
/// ### Returns
///
/// A `Result` containing either:
/// - `Ok(String)`: The generated text completion if the API call is successful and the response is valid.
/// - `Err(Box<dyn std::error::Error>)`: An error message if the API call fails, the response is invalid, or a safety concern is detected.
///
/// ### Example
///
/// ```rust
/// use tokio::runtime::Runtime;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///    let rt = Runtime::new()?;
///    let prompt = "Tell me a joke.";
///    let result = rt.block_on(generate_completion(prompt));
///    
///    match result {
///        Ok(completion) => println!("Generated text: {}", completion),
///        Err(e) => eprintln!("Error: {}", e),
///    }
///     
///    Ok(())
/// }
/// ```

pub async fn generate_completion(prompt: &str) -> Result<String, Box<dyn std::error::Error>> {
    // ... load API key from .env file
    dotenv().ok();
    let api_key = env::var("GOOGLE_API_KEY").expect("GOOGLE_API_KEY must be set");

    // ... create client
    let client = Client::new();

    #[rustfmt::skip]
    // let url = format!("https://generativelanguage.googleapis.com/v1beta2/models/chat-bison-001:generateMessage?key={}", api_key); // text-only model
    #[rustfmt::skip]
    let url = format!("https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key={}",api_key); // general use model

    // ... post request to API
    let payload = RequestPayload {
        #[rustfmt::skip]
        contents: vec![Content { parts: vec![Part { text: prompt.to_string(), }], }],
    };

    // ... API Call
    let response = client
        .post(url)
        .header(header::CONTENT_TYPE, "application/json")
        // .body(serialized_payload) // passing string (new method uses macro)
        .json(&payload)
        .send()
        .await?;

    // ... HTTP Status Check
    let status = response.status();
    if status != StatusCode::OK {
        let error_text = response.text().await?;
        return Err(format!("Request failed: {} - {}", status, error_text).into());
    }

    let response_text = response.text().await?;

    // ... parse the response
    decoder::parse_response(&response_text) // Pass the &str to parse_response
}
